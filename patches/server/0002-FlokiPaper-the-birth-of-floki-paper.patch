From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: qIooIp <dino.kanizaj@gmail.com>
Date: Thu, 26 Sep 2024 09:31:02 +0200
Subject: [PATCH] (FlokiPaper) the birth of floki paper


diff --git a/src/main/java/com/ngxdev/ItemStackArrayList.java b/src/main/java/com/ngxdev/ItemStackArrayList.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2f36f3232852100ab2d9c6fe6aaab3f9ae50193
--- /dev/null
+++ b/src/main/java/com/ngxdev/ItemStackArrayList.java
@@ -0,0 +1,113 @@
+package com.ngxdev;
+
+import net.minecraft.core.NonNullList;
+import net.minecraft.world.item.ItemStack;
+import org.apache.commons.lang.Validate;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.AbstractList;
+import java.util.Arrays;
+import java.util.List;
+
+public class ItemStackArrayList extends AbstractList<ItemStack> {
+    public static ItemStackArrayList fromList(List<ItemStack> list) {
+        if (list instanceof ItemStackArrayList ours) {
+            return ours;
+        }
+        return new ItemStackArrayList(list);
+    }
+
+    private static ItemStack[] createArray(int size) {
+        ItemStack[] array = new ItemStack[size];
+        Arrays.fill(array, ItemStack.EMPTY);
+        return array;
+    }
+
+    private final ItemStack[] items;
+
+    private long bitSet = 0;
+    private final long allBits;
+
+    private static class OurNonNullList extends NonNullList<ItemStack> {
+        protected OurNonNullList(List<ItemStack> delegate) {
+            super(delegate, ItemStack.EMPTY);
+        }
+    }
+
+    public final NonNullList<ItemStack> nonNullList = new OurNonNullList(this);
+
+    private ItemStackArrayList(List<ItemStack> list) {
+        this(list.size());
+
+        for (int i = 0; i < list.size(); i++) {
+            this.set(i, list.get(i));
+        }
+    }
+
+    public ItemStackArrayList(int size) {
+        Validate.isTrue(size < Long.BYTES * 8, "size is too large");
+
+        this.items = createArray(size);
+        this.allBits = ((1L << size) - 1);
+    }
+
+    public boolean isCompletelyEmpty() {
+        return this.bitSet == 0;
+    }
+
+    public boolean hasFullStacks() {
+        return (this.bitSet & this.allBits) == allBits;
+    }
+
+    @Override
+    public ItemStack set(int index, @NotNull ItemStack itemStack) {
+        ItemStack existing = this.items[index];
+
+        this.items[index] = itemStack;
+
+        if (itemStack == ItemStack.EMPTY) {
+            this.bitSet &= ~(1L << index);
+        } else {
+            this.bitSet |= 1L << index;
+        }
+
+        return existing;
+    }
+
+    @NotNull
+    @Override
+    public ItemStack get(int var0) {
+        return this.items[var0];
+    }
+
+    @Override
+    public int size() {
+        return this.items.length;
+    }
+
+    @Override
+    public void clear() {
+        Arrays.fill(this.items, ItemStack.EMPTY);
+    }
+
+    // these are unsupported for block inventories which have a static size
+    @Override
+    public void add(int var0, ItemStack var1) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ItemStack remove(int var0) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String toString() {
+        return "ItemListWithBitset{" +
+        "items=" + Arrays.toString(items) +
+        ", bitSet=" + Long.toString(bitSet, 2) +
+        ", allBits=" + Long.toString(allBits, 2) +
+        ", size=" + this.items.length +
+        '}';
+    }
+}
diff --git a/src/main/java/com/ngxdev/fake/EmptyChannel.java b/src/main/java/com/ngxdev/fake/EmptyChannel.java
new file mode 100644
index 0000000000000000000000000000000000000000..a896b94fc3577afed330765b1dd0c9bbbc6e4e97
--- /dev/null
+++ b/src/main/java/com/ngxdev/fake/EmptyChannel.java
@@ -0,0 +1,102 @@
+package com.ngxdev.fake;
+
+import io.netty.channel.AbstractChannel;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelConfig;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelMetadata;
+import io.netty.channel.ChannelOutboundBuffer;
+import io.netty.channel.ChannelPromise;
+import io.netty.channel.DefaultChannelConfig;
+import io.netty.channel.EventLoop;
+
+import java.net.SocketAddress;
+
+public class EmptyChannel extends AbstractChannel {
+    private final ChannelConfig config = new DefaultChannelConfig(this);
+
+    public EmptyChannel(Channel parent) {
+        super(parent);
+    }
+
+    @Override
+    public ChannelConfig config() {
+        config.setAutoRead(true);
+        return config;
+    }
+
+    @Override
+    protected void doBeginRead() throws Exception {
+    }
+
+    @Override
+    protected void doBind(SocketAddress arg0) throws Exception {
+    }
+
+    @Override
+    protected void doClose() throws Exception {
+    }
+
+    @Override
+    protected void doDisconnect() throws Exception {
+    }
+
+    @Override
+    protected void doWrite(ChannelOutboundBuffer arg0) throws Exception {
+    }
+
+    @Override
+    public boolean isActive() {
+        return false;
+    }
+
+    @Override
+    protected boolean isCompatible(EventLoop arg0) {
+        return true;
+    }
+
+    @Override
+    public boolean isOpen() {
+        return false;
+    }
+
+    @Override
+    protected SocketAddress localAddress0() {
+        return null;
+    }
+
+    @Override
+    public ChannelMetadata metadata() {
+        return new ChannelMetadata(true);
+    }
+
+    @Override
+    protected AbstractUnsafe newUnsafe() {
+        return null;
+    }
+
+    @Override
+    protected SocketAddress remoteAddress0() {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture write(Object msg) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture write(Object msg, ChannelPromise promise) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture writeAndFlush(Object msg) {
+        return null;
+    }
+
+    @Override
+    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
+        return null;
+    }
+}
diff --git a/src/main/java/com/ngxdev/fake/FakeEntityPlayer.java b/src/main/java/com/ngxdev/fake/FakeEntityPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..69baaf80c9aca9287a30cf2ad22e65102aa6b35f
--- /dev/null
+++ b/src/main/java/com/ngxdev/fake/FakeEntityPlayer.java
@@ -0,0 +1,19 @@
+package com.ngxdev.fake;
+
+import com.mojang.authlib.GameProfile;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ClientInformation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.Level;
+
+public class FakeEntityPlayer extends ServerPlayer {
+    public FakeEntityPlayer(GameProfile profile) {
+        this(profile, MinecraftServer.getServer().getLevel(Level.SPOOF));
+    }
+
+    public FakeEntityPlayer(GameProfile profile, ServerLevel level) {
+        super(MinecraftServer.getServer(), level, profile, ClientInformation.createDefault());
+        connection = new FakePlayerConnection(server, new FakeNetworkManager(), this);
+    }
+}
diff --git a/src/main/java/com/ngxdev/fake/FakeNetworkManager.java b/src/main/java/com/ngxdev/fake/FakeNetworkManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..e225824ab39a8856b22758806c5106646ed5dedd
--- /dev/null
+++ b/src/main/java/com/ngxdev/fake/FakeNetworkManager.java
@@ -0,0 +1,31 @@
+package com.ngxdev.fake;
+
+import com.ngxdev.fake.EmptyChannel;
+import net.minecraft.network.Connection;
+import net.minecraft.network.protocol.PacketFlow;
+import org.jetbrains.annotations.NotNull;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+
+public class FakeNetworkManager extends Connection {
+    static SocketAddress localhost;
+
+    public FakeNetworkManager() {
+        super(PacketFlow.SERVERBOUND);
+        channel = new EmptyChannel(null);
+    }
+
+    @Override
+    public @NotNull SocketAddress getRemoteAddress() {
+        try {
+            if (localhost == null) {
+                localhost = new InetSocketAddress(InetAddress.getLocalHost(), 0);
+            }
+            return localhost;
+        } catch (Throwable e) {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/com/ngxdev/fake/FakePlayerConnection.java b/src/main/java/com/ngxdev/fake/FakePlayerConnection.java
new file mode 100644
index 0000000000000000000000000000000000000000..09a5454629298ca2cb8fb9e76f9b8e7991ab6dba
--- /dev/null
+++ b/src/main/java/com/ngxdev/fake/FakePlayerConnection.java
@@ -0,0 +1,26 @@
+package com.ngxdev.fake;
+
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import org.jetbrains.annotations.Nullable;
+
+public class FakePlayerConnection extends ServerGamePacketListenerImpl {
+
+    public FakePlayerConnection(MinecraftServer server, Connection connection, ServerPlayer player) {
+        super(server, connection, player, null);
+    }
+
+    @Override
+    public void send(Packet<?> packet) {
+
+    }
+
+    @Override
+    public void send(Packet<?> packet, @Nullable PacketSendListener packetsendlistener) {
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 58591bf2f63b9c5e97d9ce4188dff3366968a178..7848998b27fa54e7d7552c12efa606bee41493cd 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -8,13 +8,7 @@ import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.Set;
+import java.util.*;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
@@ -190,6 +184,14 @@ import org.bukkit.inventory.MainHand;
 
 public class ServerPlayer extends Player {
 
+    // Silver
+    public final List<Runnable> asyncTasks = Collections.synchronizedList(new ArrayList<>(20));
+
+    public final void execute(Runnable task) {
+        this.asyncTasks.add(task);
+    }
+    // Silver end
+
     private static final Logger LOGGER = LogUtils.getLogger();
     public long lastSave = MinecraftServer.currentTick; // Paper - Incremental chunk and player saving
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
@@ -731,7 +733,8 @@ public class ServerPlayer extends Player {
 
         // Paper start - Configurable container update tick rate
         if (--containerUpdateDelay <= 0) {
-            this.containerMenu.broadcastChanges();
+            // Silver - parallelize container synchronization
+            execute(() -> this.containerMenu.broadcastChanges());
             containerUpdateDelay = this.level().paperConfig().tickRates.containerUpdate;
         }
         // Paper end - Configurable container update tick rate
diff --git a/src/main/java/net/minecraft/server/network/PlayerChunkSender.java b/src/main/java/net/minecraft/server/network/PlayerChunkSender.java
index 12f2bf95d3ea3d29f6b4b9ec38a92f7102daa4a1..ccd2f660e005f4a49f819ee24ae1753d65d17651 100644
--- a/src/main/java/net/minecraft/server/network/PlayerChunkSender.java
+++ b/src/main/java/net/minecraft/server/network/PlayerChunkSender.java
@@ -93,9 +93,10 @@ public class PlayerChunkSender {
         handler.send(new ClientboundLevelChunkWithLightPacket(chunk, world.getLightEngine(), (BitSet)null, (BitSet)null, shouldModify));
         // Paper end - Anti-Xray
         // Paper start - PlayerChunkLoadEvent
-        if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+        // Silver - unsupported.
+        /*if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
             new io.papermc.paper.event.packet.PlayerChunkLoadEvent(new org.bukkit.craftbukkit.CraftChunk(chunk), handler.getPlayer().getBukkitEntity()).callEvent();
-        }
+        }*/
         // Paper end - PlayerChunkLoadEvent
         ChunkPos chunkPos = chunk.getPos();
         DebugPackets.sendPoiPacketsForChunk(world, chunkPos);
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 906eded9a2ab61737a30cfe89292a71237ce4eb7..b4bc696794449f29ea39c787d23443dfbe71f648 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -423,6 +423,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
     private UUID originWorld;
     public boolean freezeLocked = false; // Paper - Freeze Tick Lock API
     public boolean fixedPose = false; // Paper - Expand Pose API
+    public int trackingRange; // GenPaper
 
     public void setOrigin(@javax.annotation.Nonnull Location location) {
         this.origin = location.toVector();
diff --git a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
index f33c03e81b7ff643741f56eea055e6af260de618..ab900c4f99e803a5ea28a5f9bd955a6e51b3937c 100644
--- a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
+++ b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
@@ -413,7 +413,7 @@ public class EnderMan extends Monster implements NeutralMob {
             boolean flag = source.getDirectEntity() instanceof ThrownPotion;
             boolean flag1;
 
-            if (!source.is(DamageTypeTags.IS_PROJECTILE) && !flag) {
+            if ((!source.is(DamageTypeTags.IS_PROJECTILE) && !flag) || level().getWorld().getName().contains("endships")) {
                 flag1 = super.hurt(source, amount);
                 if (!this.level().isClientSide() && !(source.getEntity() instanceof LivingEntity) && this.random.nextInt(10) != 0) {
                     this.teleport();
diff --git a/src/main/java/net/minecraft/world/entity/monster/Guardian.java b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
index fd41ef66e2e12ec3a888bb376ef4363343914fcd..6361830c254f1db960055108437d73d4bde2b2ce 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Guardian.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Guardian.java
@@ -200,7 +200,7 @@ public class Guardian extends Monster {
 
     @Override
     public void aiStep() {
-        if (this.isAlive()) {
+        if (this.isAlive() && this.aware) {
             if (this.level().isClientSide) {
                 this.clientSideTailAnimationO = this.clientSideTailAnimation;
                 Vec3 vec3d;
diff --git a/src/main/java/net/minecraft/world/entity/monster/Vex.java b/src/main/java/net/minecraft/world/entity/monster/Vex.java
index f443006c1e32feee97b32312814e2447a50c45e2..7897619d773a9829ff67d7b14261946e8c9c4c47 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Vex.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Vex.java
@@ -81,10 +81,15 @@ public class Vex extends Monster implements TraceableEntity {
 
     @Override
     public void tick() {
-        this.noPhysics = true;
-        super.tick();
-        this.noPhysics = false;
-        this.setNoGravity(true);
+        if(this.level().spigotConfig.disableVexClipping) {
+            super.tick();
+        } else {
+            this.noPhysics = true;
+            super.tick();
+            this.noPhysics = false;
+            this.setNoGravity(true);
+        }
+
         if (this.hasLimitedLife && --this.limitedLifeTicks <= 0) {
             this.limitedLifeTicks = 20;
             this.hurt(this.damageSources().starve(), 1.0F);
diff --git a/src/main/java/net/minecraft/world/entity/monster/Witch.java b/src/main/java/net/minecraft/world/entity/monster/Witch.java
index f9ffc5f4cbfdcf5c7351a883d2e5c26492175283..c32e1b8656292bd4f57dbcaa7160e97dd68c4498 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Witch.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Witch.java
@@ -52,8 +52,8 @@ public class Witch extends Raider implements RangedAttackMob {
     private static final AttributeModifier SPEED_MODIFIER_DRINKING = new AttributeModifier(Witch.SPEED_MODIFIER_DRINKING_UUID, "Drinking speed penalty", -0.25D, AttributeModifier.Operation.ADDITION);
     private static final EntityDataAccessor<Boolean> DATA_USING_ITEM = SynchedEntityData.defineId(Witch.class, EntityDataSerializers.BOOLEAN);
     public int usingTime;
-    private NearestHealableRaiderTargetGoal<Raider> healRaidersGoal;
-    private NearestAttackableWitchTargetGoal<Player> attackPlayersGoal;
+    public NearestHealableRaiderTargetGoal<Raider> healRaidersGoal;
+    public NearestAttackableWitchTargetGoal<Player> attackPlayersGoal;
 
     public Witch(EntityType<? extends Witch> type, Level world) {
         super(type, world);
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index 90a5f6bd729148f2adc745273536e48d704fcd1e..9c6445bf9908f997df794a9d990438f563d50736 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -5,9 +5,12 @@ import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
+
+import com.ngxdev.SilverConfig;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.core.particles.SimpleParticleType;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ClientGamePacketListener;
@@ -83,6 +86,10 @@ public class FishingHook extends Projectile {
     public boolean rainInfluenced = true;
     public boolean skyInfluenced = true;
     // CraftBukkit end
+    // Focal start
+    private static final SimpleParticleType LAVA_PARTICLE = ParticleTypes.DRIPPING_LAVA;
+    private boolean wasInLava = false;
+    // Focal end
 
     private FishingHook(EntityType<? extends FishingHook> type, Level world, int luckOfTheSeaLevel, int lureLevel) {
         super(type, world);
@@ -184,7 +191,7 @@ public class FishingHook extends Projectile {
             BlockPos blockposition = this.blockPosition();
             FluidState fluid = this.level().getFluidState(blockposition);
 
-            if (fluid.is(FluidTags.WATER)) {
+            if (isWater(fluid) || isLava(fluid)) { // Focal
                 f = fluid.getHeight(this.level(), blockposition);
             }
 
@@ -248,7 +255,7 @@ public class FishingHook extends Projectile {
                 }
             }
 
-            if (!fluid.is(FluidTags.WATER)) {
+            if (isWater(fluid) || isLava(fluid)) { // Focal
                 this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.03D, 0.0D));
             }
 
@@ -354,17 +361,21 @@ public class FishingHook extends Projectile {
                     d1 = (double) ((float) Mth.floor(this.getY()) + 1.0F);
                     d2 = this.getZ() + (double) (f2 * (float) this.timeUntilHooked * 0.1F);
                     iblockdata = worldserver.getBlockState(BlockPos.containing(d0, d1 - 1.0D, d2));
-                    if (iblockdata.is(Blocks.WATER)) {
+
+                    // Focal start
+                    wasInLava = isLava(iblockdata);
+                    if (isWater(iblockdata) || wasInLava) {
                         if (this.random.nextFloat() < 0.15F) {
-                            worldserver.sendParticles(ParticleTypes.BUBBLE, d0, d1 - 0.10000000149011612D, d2, 1, (double) f1, 0.1D, (double) f2, 0.0D);
+                            worldserver.sendParticles(wasInLava ? LAVA_PARTICLE : ParticleTypes.BUBBLE, d0, d1 - 0.10000000149011612D, d2, 1, (double) f1, 0.1D, (double) f2, 0.0D);
                         }
 
                         float f3 = f1 * 0.04F;
                         float f4 = f2 * 0.04F;
 
-                        worldserver.sendParticles(ParticleTypes.FISHING, d0, d1, d2, 0, (double) f4, 0.01D, (double) (-f3), 1.0D);
-                        worldserver.sendParticles(ParticleTypes.FISHING, d0, d1, d2, 0, (double) (-f4), 0.01D, (double) f3, 1.0D);
+                        worldserver.sendParticles(wasInLava ? LAVA_PARTICLE : ParticleTypes.FISHING, d0, d1, d2, 0, (double) f4, 0.01D, (double) (-f3), 1.0D);
+                        worldserver.sendParticles(wasInLava ? LAVA_PARTICLE : ParticleTypes.FISHING, d0, d1, d2, 0, (double) (-f4), 0.01D, (double) f3, 1.0D);
                     }
+                    // Focal end
                 } else {
                     // CraftBukkit start
                     PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) this.getPlayerOwner().getBukkitEntity(), null, (FishHook) this.getBukkitEntity(), PlayerFishEvent.State.BITE);
@@ -376,8 +387,10 @@ public class FishingHook extends Projectile {
                     this.playSound(SoundEvents.FISHING_BOBBER_SPLASH, 0.25F, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
                     double d3 = this.getY() + 0.5D;
 
-                    worldserver.sendParticles(ParticleTypes.BUBBLE, this.getX(), d3, this.getZ(), (int) (1.0F + this.getBbWidth() * 20.0F), (double) this.getBbWidth(), 0.0D, (double) this.getBbWidth(), 0.20000000298023224D);
-                    worldserver.sendParticles(ParticleTypes.FISHING, this.getX(), d3, this.getZ(), (int) (1.0F + this.getBbWidth() * 20.0F), (double) this.getBbWidth(), 0.0D, (double) this.getBbWidth(), 0.20000000298023224D);
+                    // Focal start
+                    worldserver.sendParticles(wasInLava ? LAVA_PARTICLE : ParticleTypes.BUBBLE, this.getX(), d3, this.getZ(), (int) (1.0F + this.getBbWidth() * 20.0F), (double) this.getBbWidth(), 0.0D, (double) this.getBbWidth(), 0.20000000298023224D);
+                    worldserver.sendParticles(wasInLava ? LAVA_PARTICLE : ParticleTypes.FISHING, this.getX(), d3, this.getZ(), (int) (1.0F + this.getBbWidth() * 20.0F), (double) this.getBbWidth(), 0.0D, (double) this.getBbWidth(), 0.20000000298023224D);
+                    // Focal end
                     this.nibble = Mth.nextInt(this.random, 20, 40);
                     this.getEntityData().set(FishingHook.DATA_BITING, true);
                 }
@@ -399,9 +412,13 @@ public class FishingHook extends Projectile {
                     d1 = (double) ((float) Mth.floor(this.getY()) + 1.0F);
                     d2 = this.getZ() + (double) (Mth.cos(f1) * f2) * 0.1D;
                     iblockdata = worldserver.getBlockState(BlockPos.containing(d0, d1 - 1.0D, d2));
-                    if (iblockdata.is(Blocks.WATER)) {
-                        worldserver.sendParticles(ParticleTypes.SPLASH, d0, d1, d2, 2 + this.random.nextInt(2), 0.10000000149011612D, 0.0D, 0.10000000149011612D, 0.0D);
+
+                    // Focal start
+                    wasInLava = isLava(iblockdata);
+                    if (isWater(iblockdata) || wasInLava) {
+                        worldserver.sendParticles(wasInLava ? LAVA_PARTICLE : ParticleTypes.SPLASH, d0, d1, d2, 2 + this.random.nextInt(2), 0.10000000149011612D, 0.0D, 0.10000000149011612D, 0.0D);
                     }
+                    // Focal end
                 }
 
                 if (this.timeUntilLured <= 0) {
@@ -458,7 +475,8 @@ public class FishingHook extends Projectile {
         if (!iblockdata.isAir() && !iblockdata.is(Blocks.LILY_PAD)) {
             FluidState fluid = iblockdata.getFluidState();
 
-            return fluid.is(FluidTags.WATER) && fluid.isSource() && iblockdata.getCollisionShape(this.level(), pos).isEmpty() ? FishingHook.OpenWaterType.INSIDE_WATER : FishingHook.OpenWaterType.INVALID;
+            return (isWater(fluid) || isLava(fluid)) // Focal
+                && fluid.isSource() && iblockdata.getCollisionShape(this.level(), pos).isEmpty() ? FishingHook.OpenWaterType.INSIDE_WATER : FishingHook.OpenWaterType.INVALID;
         } else {
             return FishingHook.OpenWaterType.ABOVE_WATER;
         }
@@ -468,6 +486,29 @@ public class FishingHook extends Projectile {
         return this.openWater;
     }
 
+    // Focal start
+    @Override
+    public boolean isInLava() {
+        return !SilverConfig.lavaFishing && super.isInLava();
+    }
+
+    private boolean isWater(BlockState state) {
+        return state.is(Blocks.WATER);
+    }
+
+    private boolean isWater(FluidState state) {
+        return state.is(FluidTags.WATER);
+    }
+
+    private boolean isLava(BlockState state) {
+        return SilverConfig.lavaFishing && state.is(Blocks.LAVA);
+    }
+
+    private boolean isLava(FluidState state) {
+        return SilverConfig.lavaFishing && state.is(FluidTags.LAVA);
+    }
+    // Focal end
+
     @Override
     public void addAdditionalSaveData(CompoundTag nbt) {}
 
@@ -490,7 +531,7 @@ public class FishingHook extends Projectile {
 
             if (this.hookedIn != null) {
                 // CraftBukkit start
-                PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), this.hookedIn.getBukkitEntity(), (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.CAUGHT_ENTITY); // Paper - Add hand parameter to PlayerFishEvent
+                PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), this.hookedIn.getBukkitEntity(), (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.CAUGHT_ENTITY, wasInLava); // Paper - Add hand parameter to PlayerFishEvent
                 this.level().getCraftServer().getPluginManager().callEvent(playerFishEvent);
 
                 if (playerFishEvent.isCancelled()) {
@@ -519,7 +560,7 @@ public class FishingHook extends Projectile {
                     }
                     // Paper end
                     // CraftBukkit start
-                    PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), entityitem != null ? entityitem.getBukkitEntity() : null, (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.CAUGHT_FISH); // Paper - entityitem may be null // Paper - Add hand parameter to PlayerFishEvent
+                    PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), entityitem != null ? entityitem.getBukkitEntity() : null, (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.CAUGHT_FISH, wasInLava); // Paper - entityitem may be null // Paper - Add hand parameter to PlayerFishEvent
                     playerFishEvent.setExpToDrop(this.random.nextInt(6) + 1);
                     this.level().getCraftServer().getPluginManager().callEvent(playerFishEvent);
 
@@ -553,7 +594,7 @@ public class FishingHook extends Projectile {
 
             if (this.onGround()) {
                 // CraftBukkit start
-                PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), null, (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.IN_GROUND); // Paper - Add hand parameter to PlayerFishEvent
+                PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), null, (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.IN_GROUND, wasInLava); // Paper - Add hand parameter to PlayerFishEvent
                 this.level().getCraftServer().getPluginManager().callEvent(playerFishEvent);
 
                 if (playerFishEvent.isCancelled()) {
@@ -564,7 +605,7 @@ public class FishingHook extends Projectile {
             }
             // CraftBukkit start
             if (i == 0) {
-                PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), null, (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.REEL_IN); // Paper - Add hand parameter to PlayerFishEvent
+                PlayerFishEvent playerFishEvent = new PlayerFishEvent((Player) entityhuman.getBukkitEntity(), null, (FishHook) this.getBukkitEntity(), org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.REEL_IN, wasInLava); // Paper - add hand // Paper - Add hand parameter to PlayerFishEvent
                 this.level().getCraftServer().getPluginManager().callEvent(playerFishEvent);
                 if (playerFishEvent.isCancelled()) {
                     return 0;
diff --git a/src/main/java/net/minecraft/world/item/FishingRodItem.java b/src/main/java/net/minecraft/world/item/FishingRodItem.java
index 95144f0ea5e99285c0a82b9d2e60766b785a236d..67d45418db2ea1167fb4084974dfe459f369a4f9 100644
--- a/src/main/java/net/minecraft/world/item/FishingRodItem.java
+++ b/src/main/java/net/minecraft/world/item/FishingRodItem.java
@@ -45,7 +45,7 @@ public class FishingRodItem extends Item implements Vanishable {
 
                 // CraftBukkit start
                 FishingHook entityfishinghook = new FishingHook(user, world, j, i);
-                PlayerFishEvent playerFishEvent = new PlayerFishEvent((org.bukkit.entity.Player) user.getBukkitEntity(), null, (org.bukkit.entity.FishHook) entityfishinghook.getBukkitEntity(), CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.FISHING);
+                PlayerFishEvent playerFishEvent = new PlayerFishEvent((org.bukkit.entity.Player) user.getBukkitEntity(), null, (org.bukkit.entity.FishHook) entityfishinghook.getBukkitEntity(), CraftEquipmentSlot.getHand(hand), PlayerFishEvent.State.FISHING, false);
                 world.getCraftServer().getPluginManager().callEvent(playerFishEvent);
 
                 if (playerFishEvent.isCancelled()) {
diff --git a/src/main/java/net/minecraft/world/level/BaseSpawner.java b/src/main/java/net/minecraft/world/level/BaseSpawner.java
index 65c3e91ac4541c0150057dc9f012eb1ee566516e..118a3bb9fb585a7691e741c1ab4b27fe08db3654 100644
--- a/src/main/java/net/minecraft/world/level/BaseSpawner.java
+++ b/src/main/java/net/minecraft/world/level/BaseSpawner.java
@@ -118,18 +118,20 @@ public abstract class BaseSpawner {
                     if (world.noCollision(((EntityType) optional.get()).getAABB(d0, d1, d2))) {
                         BlockPos blockposition1 = BlockPos.containing(d0, d1, d2);
 
-                        if (mobspawnerdata.getCustomSpawnRules().isPresent()) {
-                            if (!((EntityType) optional.get()).getCategory().isFriendly() && world.getDifficulty() == Difficulty.PEACEFUL) {
+                        if(!world.spigotConfig.disableSpawnerChecks) {
+                            if (mobspawnerdata.getCustomSpawnRules().isPresent()) {
+                                if (!((EntityType) optional.get()).getCategory().isFriendly() && world.getDifficulty() == Difficulty.PEACEFUL) {
+                                    continue;
+                                }
+
+                                SpawnData.CustomSpawnRules mobspawnerdata_a = (SpawnData.CustomSpawnRules) mobspawnerdata.getCustomSpawnRules().get();
+
+                                if (!mobspawnerdata_a.blockLightLimit().isValueInRange(world.getBrightness(LightLayer.BLOCK, blockposition1)) || !mobspawnerdata_a.skyLightLimit().isValueInRange(world.getBrightness(LightLayer.SKY, blockposition1))) {
+                                    continue;
+                                }
+                            } else if (!SpawnPlacements.checkSpawnRules((EntityType) optional.get(), world, MobSpawnType.SPAWNER, blockposition1, world.getRandom())) {
                                 continue;
                             }
-
-                            SpawnData.CustomSpawnRules mobspawnerdata_a = (SpawnData.CustomSpawnRules) mobspawnerdata.getCustomSpawnRules().get();
-
-                            if (!mobspawnerdata_a.blockLightLimit().isValueInRange(world.getBrightness(LightLayer.BLOCK, blockposition1)) || !mobspawnerdata_a.skyLightLimit().isValueInRange(world.getBrightness(LightLayer.SKY, blockposition1))) {
-                                continue;
-                            }
-                        } else if (!SpawnPlacements.checkSpawnRules((EntityType) optional.get(), world, MobSpawnType.SPAWNER, blockposition1, world.getRandom())) {
-                            continue;
                         }
                         // Paper start - PreCreatureSpawnEvent
                         com.destroystokyo.paper.event.entity.PreSpawnerSpawnEvent event = new com.destroystokyo.paper.event.entity.PreSpawnerSpawnEvent(
@@ -168,7 +170,7 @@ public abstract class BaseSpawner {
                         if (entity instanceof Mob) {
                             Mob entityinsentient = (Mob) entity;
 
-                            if (mobspawnerdata.getCustomSpawnRules().isEmpty() && !entityinsentient.checkSpawnRules(world, MobSpawnType.SPAWNER) || !entityinsentient.checkSpawnObstruction(world)) {
+                            if ((!entity.level().spigotConfig.disableSpawnerChecks && mobspawnerdata.getCustomSpawnRules().isEmpty() && !entityinsentient.checkSpawnRules(world, MobSpawnType.SPAWNER)) || !entityinsentient.checkSpawnObstruction(world)) {
                                 continue;
                             }
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 19f23a6c8fb5c02843c27fb8a242ec9d0d1b538b..3dca04ed2c136397ba07449ac4f0909d914c10b9 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -108,6 +108,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final ResourceKey<Level> OVERWORLD = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("overworld"));
     public static final ResourceKey<Level> NETHER = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("the_nether"));
     public static final ResourceKey<Level> END = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("the_end"));
+
+    // Silver - fake player support
+    public static final ResourceKey<Level> SPOOF = ResourceKey.create(Registries.DIMENSION, new ResourceLocation("spoof"));
+
     public static final int MAX_LEVEL_SIZE = 30000000;
     public static final int LONG_PARTICLE_CLIP_RANGE = 512;
     public static final int SHORT_PARTICLE_CLIP_RANGE = 32;
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 22036ed3ea0629bc12981a8d91a03e55cc2117d6..d3b9275820097d0d05e2f3c8a3657f4c3be129be 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -54,6 +54,7 @@ import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.Property;
+import net.minecraft.world.level.chunk.ChunkAccess;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.storage.loot.LootParams;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
@@ -61,6 +62,7 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.bukkit.Chunk;
 import org.slf4j.Logger;
 
 public class Block extends BlockBehaviour implements ItemLike {
@@ -610,6 +612,13 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
     // Spigot end
 
+    // Focal start
+    public boolean hasChunkAttribute(LevelReader world, BlockPos pos, Chunk.Attribute attribute) {
+        ChunkAccess chunk = world.getChunkIfLoadedImmediately(pos.getX() >> 4, pos.getZ() >> 4);
+        return chunk != null && chunk.hasAttribute(attribute);
+    }
+    // Focal end
+
     public static final class BlockStatePairKey {
 
         private final BlockState first;
diff --git a/src/main/java/net/minecraft/world/level/block/BushBlock.java b/src/main/java/net/minecraft/world/level/block/BushBlock.java
index bed3d9c781c7d3ca260027b4737970889a54689c..fbb17923db8aa44500178259251062556726562f 100644
--- a/src/main/java/net/minecraft/world/level/block/BushBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BushBlock.java
@@ -3,6 +3,7 @@ package net.minecraft.world.level.block;
 import com.mojang.serialization.MapCodec;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.tags.BlockTags;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.LevelAccessor;
@@ -27,7 +28,7 @@ public abstract class BushBlock extends Block {
     @Override
     public BlockState updateShape(BlockState state, Direction direction, BlockState neighborState, LevelAccessor world, BlockPos pos, BlockPos neighborPos) {
         // CraftBukkit start
-        if (!state.canSurvive(world, pos)) {
+        if (!state.canSurvive(world, pos) && !(world instanceof ServerLevel && ((ServerLevel) world).spigotConfig.ignoreCropLight)) {
             if (!(world instanceof net.minecraft.server.level.ServerLevel && ((net.minecraft.server.level.ServerLevel) world).hasPhysicsEvent) || !org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPhysicsEvent(world, pos).isCancelled()) { // Paper
                 return Blocks.AIR.defaultBlockState();
             }
diff --git a/src/main/java/net/minecraft/world/level/block/CactusBlock.java b/src/main/java/net/minecraft/world/level/block/CactusBlock.java
index ba4aaf850af36a84517c70581e141157c4f15b99..e2620dbc8f882066914e74dca48bd805542c3add 100644
--- a/src/main/java/net/minecraft/world/level/block/CactusBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CactusBlock.java
@@ -119,11 +119,11 @@ public class CactusBlock extends Block {
         return false;
     }
 
-    @Override
+    /*@Override
     public void entityInside(BlockState state, Level world, BlockPos pos, Entity entity) {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(world, pos)).callEvent()) { return; } // Paper - Add EntityInsideBlockEvent
         entity.hurt(world.damageSources().cactus().directBlock(world, pos), 1.0F); // CraftBukkit
-    }
+    }*/
 
     @Override
     protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
diff --git a/src/main/java/net/minecraft/world/level/block/ChangeOverTimeBlock.java b/src/main/java/net/minecraft/world/level/block/ChangeOverTimeBlock.java
index daae7fd6e0148cfba8e359d990748a0c83a3376e..9a086e4e9c5d914cc732ff10456eefc5ea0b8c12 100644
--- a/src/main/java/net/minecraft/world/level/block/ChangeOverTimeBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ChangeOverTimeBlock.java
@@ -6,6 +6,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.Material;
 
 public interface ChangeOverTimeBlock<T extends Enum<T>> {
 
@@ -16,6 +17,10 @@ public interface ChangeOverTimeBlock<T extends Enum<T>> {
     float getChanceModifier();
 
     default void changeOverTime(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
+        if(state.getBukkitMaterial() == Material.COPPER_BLOCK) {
+            return;
+        }
+
         float f = 0.05688889F;
 
         if (random.nextFloat() < 0.05688889F) {
diff --git a/src/main/java/net/minecraft/world/level/block/CropBlock.java b/src/main/java/net/minecraft/world/level/block/CropBlock.java
index 5b96d1ae4bd8546311e986bc312b1f85883a67f4..5d3a3590b6b72c39a390be97c90fb3b41b0e084d 100644
--- a/src/main/java/net/minecraft/world/level/block/CropBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/CropBlock.java
@@ -21,6 +21,7 @@ import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.IntegerProperty;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.bukkit.Chunk;
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public class CropBlock extends BushBlock implements BonemealableBlock {
@@ -77,7 +78,7 @@ public class CropBlock extends BushBlock implements BonemealableBlock {
 
     @Override
     public void randomTick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
-        if (world.getRawBrightness(pos, 0) >= 9) {
+        if (hasChunkAttribute(world, pos, Chunk.Attribute.LIGHTLESS_CROPS) || world.getRawBrightness(pos, 0) >= 9) {
             int i = this.getAge(state);
 
             if (i < this.getMaxAge()) {
@@ -169,7 +170,7 @@ public class CropBlock extends BushBlock implements BonemealableBlock {
 
     @Override
     public boolean canSurvive(BlockState state, LevelReader world, BlockPos pos) {
-        return CropBlock.hasSufficientLight(world, pos) && super.canSurvive(state, world, pos);
+        return (hasChunkAttribute(world, pos, Chunk.Attribute.LIGHTLESS_CROPS) || CropBlock.hasSufficientLight(world, pos)) && super.canSurvive(state, world, pos);
     }
 
     protected static boolean hasSufficientLight(LevelReader world, BlockPos pos) {
diff --git a/src/main/java/net/minecraft/world/level/block/FarmBlock.java b/src/main/java/net/minecraft/world/level/block/FarmBlock.java
index 6e4c852c93f2418ea69e485ed3a10cbe3a6e3bd2..4c1ac177607007f726f521f70da7fcab23ec9b96 100644
--- a/src/main/java/net/minecraft/world/level/block/FarmBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/FarmBlock.java
@@ -151,8 +151,9 @@ public class FarmBlock extends Block {
     }
 
     private static boolean isNearWater(LevelReader world, BlockPos pos) {
+        return true;
         // Paper start - Perf: remove abstract block iteration
-        int xOff = pos.getX();
+        /*int xOff = pos.getX();
         int yOff = pos.getY();
         int zOff = pos.getZ();
 
@@ -172,7 +173,7 @@ public class FarmBlock extends Block {
         }
 
         return false;
-        // Paper end - Perf: remove abstract block iteration
+        // Paper end - Perf: remove abstract block iteration*/
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java b/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java
index 04957d461d0e968d443737068aaeec1d0bce78b2..6c6ee6bc85dd99dbb27d3da17c370a4575416702 100644
--- a/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/SugarCaneBlock.java
@@ -19,6 +19,7 @@ import net.minecraft.world.level.block.state.properties.IntegerProperty;
 import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.bukkit.Chunk;
 
 public class SugarCaneBlock extends Block {
 
@@ -91,6 +92,12 @@ public class SugarCaneBlock extends Block {
             return true;
         } else {
             if (iblockdata1.is(BlockTags.DIRT) || iblockdata1.is(BlockTags.SAND)) {
+                // Focal Start
+                if (hasChunkAttribute(world, pos, Chunk.Attribute.WATERLESS_SUGARCANE)) {
+                    return true;
+                }
+                // Focal end
+
                 BlockPos blockposition1 = pos.below();
                 Iterator iterator = Direction.Plane.HORIZONTAL.iterator();
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
index f7e5e016a7028a9196e689e950805b0d5b31fe38..2b478413bb048f1be0d3da2f5a8de34b7bf4e957 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -52,6 +52,8 @@ import net.minecraft.world.level.lighting.ChunkSkyLightSources;
 import net.minecraft.world.level.material.Fluid;
 import net.minecraft.world.ticks.SerializableTickContainer;
 import net.minecraft.world.ticks.TickContainerAccess;
+import org.bukkit.Chunk;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiomeSource, LightChunk, StructureAccess {
@@ -453,6 +455,16 @@ public abstract class ChunkAccess implements BlockGetter, BiomeManager.NoiseBiom
         this.setUnsaved(true);
     }
 
+    // Focal start
+    public abstract void addAttribute(@NotNull Chunk.Attribute attribute);
+
+    public abstract void removeAttribute(@NotNull Chunk.Attribute attribute);
+
+    public abstract @NotNull Set<Chunk.Attribute> getAttributes();
+
+    public abstract boolean hasAttribute(@NotNull Chunk.Attribute attribute);
+    // Focal end
+
     @Override
     public int getMinBuildHeight() {
         return this.levelHeightAccessor.getMinBuildHeight();
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 6ec3fc801453fd54c25b642e6fa71c19b463311d..eaa7076e3debafc667d35c017097fa5b8e81fddf 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -5,12 +5,16 @@ import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Maps;
 import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.world.ChunkEntitySlices;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
+
+import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
@@ -50,10 +54,20 @@ import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
+import org.bukkit.Chunk;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
 public class LevelChunk extends ChunkAccess {
 
+    public int lastWorkTick;
+    public int entityCount;
+    public float closestPlayer = 0;
+    private final Set<Chunk.Attribute> attributes = EnumSet.noneOf(Chunk.Attribute.class); // Focal
+
+    @Nullable
+    public ChunkEntitySlices entitySlices;
+
     static final Logger LOGGER = LogUtils.getLogger();
     private static final TickingBlockEntity NULL_TICKER = new TickingBlockEntity() {
         @Override
@@ -299,6 +313,28 @@ public class LevelChunk extends ChunkAccess {
         }
     }
 
+    // Focal start
+    @Override
+    public void addAttribute(@NotNull Chunk.Attribute attribute) {
+        attributes.add(attribute);
+    }
+
+    @Override
+    public void removeAttribute(@NotNull Chunk.Attribute attribute) {
+        attributes.remove(attribute);
+    }
+
+    @Override
+    public @NotNull Set<Chunk.Attribute> getAttributes() {
+        return attributes;
+    }
+
+    @Override
+    public boolean hasAttribute(@NotNull Chunk.Attribute attribute) {
+        return attributes.contains(attribute);
+    }
+    // Focal end
+
     // Paper start - Perf: Reduce instructions and provide final method
     public BlockState getBlockState(final int x, final int y, final int z) {
         return this.getBlockStateFinal(x, y, z);
diff --git a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
index 7aa585875dad5296526bb5d67fc5ea0f8875e452..e2cb6a7036acfd08b88f79eb9054a26c5422fd64 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ProtoChunk.java
@@ -2,10 +2,8 @@ package net.minecraft.world.level.chunk;
 
 import com.google.common.collect.Lists;
 import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.List;
-import java.util.Map;
+
+import java.util.*;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
@@ -35,6 +33,8 @@ import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.ticks.LevelChunkTicks;
 import net.minecraft.world.ticks.ProtoChunkTicks;
 import net.minecraft.world.ticks.TickContainerAccess;
+import org.bukkit.Chunk;
+import org.jetbrains.annotations.NotNull;
 
 public class ProtoChunk extends ChunkAccess {
     @Nullable
@@ -46,6 +46,7 @@ public class ProtoChunk extends ChunkAccess {
     private BelowZeroRetrogen belowZeroRetrogen;
     private final ProtoChunkTicks<Block> blockTicks;
     private final ProtoChunkTicks<Fluid> fluidTicks;
+    private final Set<Chunk.Attribute> attributes = EnumSet.noneOf(Chunk.Attribute.class); // Focal
 
     public ProtoChunk(ChunkPos pos, UpgradeData upgradeData, LevelHeightAccessor world, Registry<Biome> biomeRegistry, @Nullable BlendingData blendingData) {
         this(pos, upgradeData, (LevelChunkSection[])null, new ProtoChunkTicks<>(), new ProtoChunkTicks<>(), world, biomeRegistry, blendingData);
@@ -329,4 +330,26 @@ public class ProtoChunk extends ChunkAccess {
     public LevelHeightAccessor getHeightAccessorForGeneration() {
         return (LevelHeightAccessor)(this.isUpgrading() ? BelowZeroRetrogen.UPGRADE_HEIGHT_ACCESSOR : this);
     }
+
+    // Focal start
+    @Override
+    public void addAttribute(@NotNull Chunk.Attribute attribute) {
+        attributes.add(attribute);
+    }
+
+    @Override
+    public void removeAttribute(@NotNull Chunk.Attribute attribute) {
+        attributes.remove(attribute);
+    }
+
+    @Override
+    public @NotNull Set<Chunk.Attribute> getAttributes() {
+        return attributes;
+    }
+
+    @Override
+    public boolean hasAttribute(@NotNull Chunk.Attribute attribute) {
+        return attributes.contains(attribute);
+    }
+    // Focal end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index dca5f25cf331b5550e9be491b4e8a3466531e021..593a8999ba499f0486432d79a38daefa4d6bfd9c 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -3,9 +3,8 @@ package org.bukkit.craftbukkit;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Predicates;
 import com.mojang.serialization.Codec;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Objects;
+
+import java.util.*;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
@@ -50,6 +49,8 @@ import org.bukkit.generator.structure.GeneratedStructure;
 import org.bukkit.generator.structure.Structure;
 import org.bukkit.persistence.PersistentDataContainer;
 import org.bukkit.plugin.Plugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Unmodifiable;
 
 public class CraftChunk implements Chunk {
     private final ServerLevel worldServer;
@@ -276,6 +277,32 @@ public class CraftChunk implements Chunk {
         return false;
     }
 
+    // Focal start
+    @Override
+    public void addAttributes(Attribute @NotNull ... attributes) {
+        for (Attribute attribute : attributes) {
+            this.getHandle(ChunkStatus.FULL).addAttribute(attribute);
+        }
+    }
+
+    @Override
+    public void removeAttributes(Attribute @NotNull... attributes) {
+        for (Attribute attribute : attributes) {
+            this.getHandle(ChunkStatus.FULL).removeAttribute(attribute);
+        }
+    }
+
+    @Override
+    public @NotNull @Unmodifiable Set<Attribute> getAttributes() {
+        return Collections.unmodifiableSet(this.getHandle(ChunkStatus.FULL).getAttributes());
+    }
+
+    @Override
+    public boolean hasAttribute(@NotNull Attribute attribute) {
+        return this.getHandle(ChunkStatus.FULL).hasAttribute(attribute);
+    }
+    // Focal end
+
     @Override
     public ChunkSnapshot getChunkSnapshot() {
         return this.getChunkSnapshot(true, false, false);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 8698104e3eb98e2cc5da5de87a8f538860c1d91d..0db085849fa34f5d6c21aba0e540787f1e87706b 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1165,6 +1165,18 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return set;
     }
 
+    // GenPaper start
+    @Override
+    public int getTrackingRange() {
+        return getHandle().trackingRange;
+    }
+
+    @Override
+    public void setTrackingRange(int trackingRange) {
+        getHandle().trackingRange = trackingRange;
+    }
+    // GenPaper end
+
     @Override
     public boolean spawnAt(Location location, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
         Preconditions.checkNotNull(location, "location cannot be null");
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 97bace6bf9281769b1884e981eb776be157e4c2b..34861a136a8f57fe61f93bcb28f1c09eb96ab7b8 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -9,7 +9,7 @@ import org.bukkit.Bukkit;
 
 public final class Versioning {
     public static String getBukkitVersion() {
-        String result = "Unknown-Version";
+        String result = "1.20.4-R0.1-SNAPSHOT";
 
         InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/com.floki.api/floki-api/pom.properties"); // Floki
         Properties properties = new Properties();
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index c39894e824334f1dc52e0466cf9d84f7e219be70..e6123e221fa064edffade2dd6035f9ae2f1a7b30 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -383,7 +383,7 @@ public class ActivationRange
         }
         // Paper start - special case always immunities
         // immunize brand new entities, dead entities, and portal scenarios
-        if (entity.defaultActivationState || entity.tickCount < 20*10 || !entity.isAlive() || entity.isInsidePortal || entity.portalCooldown > 0) {
+        if (entity.defaultActivationState || entity.level().spigotConfig.keepMobsActive || entity.tickCount < 20*10 || !entity.isAlive() || entity.isInsidePortal || entity.portalCooldown > 0) {
             return true;
         }
         // immunize leashed entities
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 1cf6d4f854d89c515e48e1fb365eb95ff9340765..1ffb9b0c979bf031567c401405c6708096547e50 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -321,6 +321,34 @@ public class SpigotWorldConfig
         this.log( "Zombie Aggressive Towards Villager: " + this.zombieAggressiveTowardsVillager );
     }
 
+    public boolean disableSpawnerChecks;
+    private void disableSpawnerChecks()
+    {
+        this.disableSpawnerChecks = this.getBoolean("disable-spawner-checks", false );
+        this.log( "Disable Spawner Checks: " + this.disableSpawnerChecks );
+    }
+
+    public boolean ignoreCropLight;
+    private void ignoreCropLight()
+    {
+        this.ignoreCropLight = this.getBoolean("ignore-crop-light", false );
+        this.log( "Ignore Crop Light: " + this.ignoreCropLight );
+    }
+
+    public boolean keepMobsActive;
+    private void keepMobsActive()
+    {
+        this.keepMobsActive = this.getBoolean("keep-mobs-active", false );
+        this.log( "Keep Mobs Active: " + this.keepMobsActive );
+    }
+
+    public boolean disableVexClipping;
+    private void disableVexClipping()
+    {
+        this.disableVexClipping = this.getBoolean("disable-vex-clipping", true );
+        this.log( "Disable Vex Clipping: " + this.disableVexClipping );
+    }
+
     public boolean nerfSpawnerMobs;
     private void nerfSpawnerMobs()
     {
